#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64  : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "shared_structs.h"
#include "rng.glsl"

#define pi (3.141592)
#define pi2 (2.0*pi)

// The ray payload; structure is defined in shared_structs.h;
// Attached to a ray, and used to communicate between shader stages.
layout(location=0) rayPayloadEXT RayPayload payload;

// Push constant for ray tracing; structure is defined in shared_structs.h;
// Filled in by application, and pushed to shaders as part of the pipeline invocation
layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };

// Ray tracing descriptor set: 0:acceleration structure, and 1: color output image
layout(set=0, binding=0) uniform accelerationStructureEXT topLevelAS;
layout(set=0, binding=1, rgba32f) uniform image2D colCurr; // Output image: m_rtColCurrBuffer
layout(set=0, binding=2, scalar) buffer _emitter { Emitter list[]; } emitter;
// Many more buffers (at bindings 2 ... 7) will be added to this eventually.
layout(set=0, binding=3, rgba32f) uniform image2D colPrev;
layout(set=0, binding=4, rgba32f) uniform image2D ndCurr;
layout(set=0, binding=5, rgba32f) uniform image2D ndPrev;
layout(set=0, binding=6, rgba32f) uniform image2D kdCurr;
layout(set=0, binding=7, rgba32f) uniform image2D kdPrev;

// Object model descriptor set: 0: matrices, 1:object buffer addresses, 2: texture list
layout(set=1, binding=0) uniform _MatrixUniforms { MatrixUniforms mats; };
layout(set=1, binding=1, scalar) buffer ObjDesc_ { ObjDesc i[]; } objDesc;
layout(set=1, binding=2) uniform sampler2D textureSamplers[];

// Object buffered data; dereferenced from ObjDesc addresses;  Must be global
layout(buffer_reference, scalar) buffer Vertices {Vertex v[]; }; // Position, normals, ..
layout(buffer_reference, scalar) buffer Indices {ivec3 i[]; }; // Triangle indices
layout(buffer_reference, scalar) buffer Materials {Material m[]; }; // Array of all materials
layout(buffer_reference, scalar) buffer MatIndices {int i[]; }; // Material ID for each triangle

// @@ Raycasting: Write EvalBrdf -- The BRDF lighting calculation
vec3 EvalBrdf(vec3 N, vec3 L, vec3 V, Material mat) 
{
    vec3 Kd = mat.diffuse;
    vec3 Ks = mat.specular;
    const float alpha = mat.shininess;

    vec3 H = normalize(L + V);
    float LH = dot(L, H);

    // L = Wi
    // V = Wo
    // m = H

    // F factor
    vec3 F = Ks + (vec3(1.0) - Ks) * pow((1 - LH), 5);

    // D factor
    float mN = dot(H, N);
    float tan_square_theta_m = (1.0 - mN * mN) / mN * mN;
    float alpha_square = alpha * alpha;
    float D = clamp(mN, 0.0, 1.0) * alpha_square
            / (pi * pow(mN, 4) * pow(alpha_square + tan_square_theta_m, 2));

    // G factor with V
    float mV = dot(H, V);
    float NV = dot(N, V);
    float tan_square_theta_v = (1.0 -  NV * NV) /  NV * NV;
    float GV;
    if(NV > 1.0 || sqrt(tan_square_theta_v) == 0)
    {
        GV = 1.0;
    }
    else
    {
        int x;
        if (mV / NV > 0) x = 1;
        else x = 0;
        GV = x * 2 / (1.0 + sqrt(1 + alpha_square * tan_square_theta_v));
    }

    // G factor with L
    float mL = LH; // dot(L, H);
    float NL = dot(N, L);
    float tan_square_theta_l = (1.0 -  NL * NL) /  NL * NL;
    float GL;
    if(NL > 1.0 || sqrt(tan_square_theta_l) == 0)
    {
        GL = 1.0;
    }
    else
    {
        int x;
        if (mL / NL > 0) x = 1;
        else x = 0;
        GL = x * 2 / (1.0 + sqrt(1 + alpha_square * tan_square_theta_l));
    }
    float G = GV * GL;

    return max(NL, 0.0) * ((Kd / pi) + ( (D * G * F) / (4 * abs(NL) * abs(NV)) ) );
}

// @@ Pathtracing: Write SampleBrdf, PdfBrdf, ...
//   vec3 SampleBrdf(inout uint seed, in vec3 N) { }
//   float PdfLight(float area) { }
// and more

vec3 SampleLobe(vec3 A, float c, float phi) {
    // Step 1: Calculate s
    float s = sqrt(1.0 - c * c);

    // Step 2: Create vector K centered around Z-axis
    vec3 K = vec3(s * cos(phi), s * sin(phi), c);  // Vector centered around Z-axis

    // Step 3: Handle special cases for rotation alignment
    if (abs(A.z - 1.0) < 1e-3) {
        // A is approximately equal to Z-axis (A = +Z)
        return K;
    }
    if (abs(A.z + 1.0) < 1e-3) {
        // A is approximately equal to -Z-axis (A = -Z), rotate 180 degrees around X-axis
        return vec3(K.x, -K.y, -K.z);
    }

    // Step 4: Create an orthonormal basis (T, B, A)
    vec3 B = normalize(vec3(-A.y, A.x, 0.0));  // Vector orthogonal to A
    vec3 C = cross(A, B);                      // Cross product to form an orthonormal basis

    // Step 5: Rotate K from Z-axis to align with vector A
    return K.x * B + K.y * C + K.z * A;
}

vec3 SampleBrdf(inout uint seed, in vec3 N)
{
    // Use the provided SampleLobe function for generating sample direction
    float sqrtR1 = sqrt(rnd(seed));  // This represents cosine value
    float phi = 2.0 * pi * rnd(seed); // Azimuthal angle around N

    // Generate the sample direction using SampleLobe
    return SampleLobe(N, sqrtR1, phi);
}

float PdfBrdf(vec3 N, vec3 Wi)
{
    // Cosine-weighted PDF for diffuse BRDF
    return abs(dot(N, Wi)) / pi;
}

// Sample a triangle surface
vec3 SampleTriangle(inout uint seed, vec3 A, vec3 B, vec3 C) 
{
    float b2 = rnd(seed);
    float b1 = rnd(seed);
    float b0 = 1.0 - b1 - b2;

    if (b0 < 0.0) 
    {
        b1 = 1.0 - b1;
        b2 = 1.0 - b2;
        b0 = 1.0 - b1 - b2;
    }

    return b0 * A + b1 * B + b2 * C;
}

// Geometry factor calculation
float GeometryFactor(vec3 Pa, vec3 Na, vec3 Pb, vec3 Nb) 
{
    vec3 D = Pa - Pb;
    return abs((dot(D, Na) * dot(D, Nb)) / pow(dot(D, D), 2.0));
}

// Sample a light from the emitter list
Emitter SampleLight(inout uint seed) 
{
    Emitter light = emitter.list[uint(rnd(seed) * emitter.list.length())];
    light.point = SampleTriangle(seed, light.v0, light.v1, light.v2);
    return light;
}

// PDF for sampling a light
float PdfLight(const Emitter light) 
{
    return 1.0 / (light.area * emitter.list.length());
}

// Evaluate light emission
vec3 EvalLight(const Emitter light) 
{
    return light.emission;
}

// Given a ray's payload indicating a triangle has been hit
// (payload.instanceIndex, and payload.primitiveIndex),
// lookup/calculate the material, texture and normal at the hit point
// from the three vertices of the hit triangle.
void GetHitObjectData(out Material mat, out vec3 nrm)
{
    // Object data (containing 4 device addresses)
    ObjDesc    objResources = objDesc.i[payload.instanceIndex];
    
    // Dereference the object's 4 device addresses
    Vertices   vertices    = Vertices(objResources.vertexAddress);
    Indices    indices     = Indices(objResources.indexAddress);
    Materials  materials   = Materials(objResources.materialAddress);
    MatIndices matIndices  = MatIndices(objResources.materialIndexAddress);
  
    // Use gl_PrimitiveID to access the triangle's vertices and material
    ivec3 ind    = indices.i[payload.primitiveIndex]; // The triangle hit
    int matIdx   = matIndices.i[payload.primitiveIndex]; // The triangles material index
    mat = materials.m[matIdx]; // The triangles material

    // Vertex of the triangle (Vertex has pos, nrm, tex)
    Vertex v0 = vertices.v[ind.x];
    Vertex v1 = vertices.v[ind.y];
    Vertex v2 = vertices.v[ind.z];

    // Compute normal at hit position using the provided barycentric coordinates.
    const vec3 bc = payload.bc; // The barycentric coordinates of the hit point
    nrm  = bc.x*v0.nrm + bc.y*v1.nrm + bc.z*v2.nrm; // Normal = combo of three vertex normals

    // If the material has a texture, read texture and use as the
    // point's diffuse color.
    if (mat.textureId >= 0) {
        vec2 uv =  bc.x*v0.texCoord + bc.y*v1.texCoord + bc.z*v2.texCoord;
        uint txtId = objResources.txtOffset + mat.textureId; // tex coord from three vertices
        mat.diffuse = texture(textureSamplers[(txtId)], uv).xyz; }
}

void main() 
{
    // Raycasting: Since the alignment of pcRay is SO easy to get wrong, test it
    // here and flag problems with a fully red screen.
    if (pcRay.alignmentTest != 1234) {
        imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(1,0,0,0));
        return; }
    
    // This shader's invocation is for the pixel indicated by
    // gl_LaunchIDEXT. Calculate that pixel's center (in NDC) and
    // convert to a ray in world coordinates.
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    vec2 pixelNDC = pixelCenter/vec2(gl_LaunchSizeEXT.xy)*2.0 - 1.0;
 
    vec3 eyeW    = (mats.viewInverse * vec4(0, 0, 0, 1)).xyz;
    vec4 pixelH = mats.viewInverse * mats.projInverse * vec4(pixelNDC.x, pixelNDC.y, 1, 1);
    vec3 pixelW = pixelH.xyz/pixelH.w;

    // This pixel's ray:
    vec3 rayOrigin    = eyeW;
    vec3 rayDirection = normalize(pixelW - eyeW);

    // The ray-casting / path-tracing block/loop will store the
    // pixel's calculated color in C.
    vec3 C = vec3(0,0,0);
    // The path tracing algorithm will accumulate a product of f/p weights in W.
    vec3 W = vec3(1,1,1);
    
    // @@ Pathtracing: Initialize random pixel seed *very* carefully! (See notes.)
    payload.seed = tea(gl_LaunchIDEXT.y*gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pcRay.frameSeed);
    
    // @@ Raycasting: Notice that all the ray casting code is places
    // in this loop that's not really a loop since it executes only
    // once.  WHY?  Just looking ahead a bit into the next (path
    // tracing) project where this loop will actually loop.

    bool firstHit;    // Boolean indicating if the first ray hit something
    float firstDepth; // Depth value from the hit-shader¡¯s gl_HitTEXT
    vec3 firstNrm;    // Normal at the hit position
    vec3 firstKd;     // Diffuse color from the material or texture
    vec3 firstPos = vec3(0.0);

    // @@ Pathtracing: Eventually, this will be the Monte-Carlo loop.
    for (int i=0; i<pcRay.depth;  i++)
    {
        payload.hit = false;
        traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, rayOrigin, 0.001, rayDirection, 10000.0, 0);

        if (!payload.hit) {
            break;
        }

        Material mat;
        vec3 nrm;
        GetHitObjectData(mat, nrm);

        // @@ History: Initialize first-hit data
        if (i == 0)
        {
            firstHit = payload.hit;  // Boolean indicating if the first ray hit something
            firstDepth = payload.hitDist; // Depth value from the hit-shader¡¯s gl_HitTEXT
            firstNrm = nrm;          // Normal at the hit position
            firstKd = mat.diffuse;   // Diffuse color from the material or texture
            firstPos = payload.hitPos;
        }

        if (dot(mat.emission, mat.emission) > 0.0) 
        {
            if(pcRay.explicitMode)
                C += 0.5 * W * mat.emission * pcRay.exposure;
            else
                C += mat.emission * W;
            break;
        }

        if(pcRay.explicitMode)
        {
            Emitter light = SampleLight(payload.seed);
            vec3 Wi =  normalize(light.point - payload.hitPos);
            float dist = length(light.point - payload.hitPos);
            payload.hit = true;

            traceRayEXT(topLevelAS,                         // acceleration structure
                    gl_RayFlagsOpaqueEXT                    // rayFlags
                    | gl_RayFlagsTerminateOnFirstHitEXT
                    | gl_RayFlagsSkipClosestHitShaderEXT,
                    0xFF,                                   // cullMask
                    0,                                      // sbtRecordOffset for the hitgroups
                    0,                                      // sbtRecordStride for the hitgroups
                    0,                                      // missIndex
                    payload.hitPos,                         // ray origin
                    0.001,                                  // ray min range
                    Wi,                                     // ray direction
                    dist - 0.001,                           // ray max range
                    0                                       // payload (location = 0)
                    );
            if (!payload.hit) 
            {
                vec3 N = normalize(nrm);
                vec3 Wo = -rayDirection;
                vec3 f = EvalBrdf(N, Wi, Wo, mat);
                float p = PdfLight(light) / GeometryFactor(payload.hitPos, N, light.point, light.normal);

                C += 0.5 * W * f / p * EvalLight(light) ;
            }
        }

        vec3 N = normalize(nrm);
        vec3 Wi = SampleBrdf(payload.seed, N);
        vec3 Wo = -rayDirection;
        vec3 f = dot(N, Wi) * EvalBrdf(N, Wi, Wo, mat);
        float p = PdfBrdf(N, Wi) * pcRay.rr;

        if (p < 1e-6) break; // Avoid division by zero

        W *= f / p; // Update path weight

        if (i > 2) 
        {
            if (rnd(payload.seed) > pcRay.rr) break;
            W /= pcRay.rr;
        }

        rayOrigin = payload.hitPos;
        rayDirection = Wi;

    } // End of Monte-Carlo block/loop
 
    // @@ Pathtracing: Accumulate C into output pixel.
    vec4 old;
    vec4 P = vec4(0.0);
    if (pcRay.clear) {
        old = vec4(0.5); // Soft initialization for new pixels
    } else {
        // Back-project current pixel to previous frame
        vec4 screenH = mats.priorViewProj * vec4(firstPos, 1.0);
        vec2 screen = ((screenH.xy / screenH.w) + vec2(1.0)) / 2.0;

        vec2 floc = screen * vec2(gl_LaunchSizeEXT.xy) - vec2(0.5);
        ivec2 iloc = ivec2(floc);
        vec2 offset = fract(floc);

        // Calculate the bilinear weights based on the fractional part of `floc`
        float w0_0 = (1.0 - offset.x) * (1.0 - offset.y);
        float w1_0 = offset.x * (1.0 - offset.y);
        float w0_1 = (1.0 - offset.x) * offset.y;
        float w1_1 = offset.x * offset.y;

        // Calculate weighted average of four neighboring pixels from colPrev buffer
        P = w0_0 * imageLoad(colPrev, iloc + ivec2(0, 0)) +
            w1_0 * imageLoad(colPrev, iloc + ivec2(1, 0)) +
            w0_1 * imageLoad(colPrev, iloc + ivec2(0, 1)) +
            w1_1 * imageLoad(colPrev, iloc + ivec2(1, 1));

        old = vec4(P.xyz / (w0_0 + w1_0 + w0_1 + w1_1), P.w);
    }

    // Accumulate C into output pixel
    float N = old.w;
    vec3 Ave = old.xyz;
    Ave += (C - Ave) / (N + 1.0);

    if (any(isnan(Ave)) || any(isinf(Ave))) {
        return;
    }

    imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(Ave, N + 1));
    // Store first hit values for normals and diffuse colors
    imageStore(kdCurr, ivec2(gl_LaunchIDEXT.xy), vec4(firstKd, 0));
    imageStore(ndCurr, ivec2(gl_LaunchIDEXT.xy), vec4(firstNrm, firstDepth));
}

//  LocalWords:  Pathtracing Raycasting
